# 
# ! Threads : 
# * Parallelism can be real due to the presence of multiple processors, and in this case we talk about multiprocessing.
# * The process, in computer science, is a dynamic entity loaded on RAM generated by a program. 
# * The process is identified by an unique code called PID.

import time
def coutdown(n):
    while n > 0:
        print(f'T-minus {n} ')
        n -=1
        time.sleep(3)

from threading import Thread
t = Thread(target=coutdown, args=(10,)) # ! istance a thread by Thread class
#t.start()   # ! start Thread

# * Creating Thread Using threading Module Thread
# To do this is necessary: 
# Define a new subcluss of the Thread class. After you have created the new thread subclass, you can create an istance of it and then start a new thread by invoking the start(), wich in turns calls run() method.

exitFlag = 0

class myThread(Thread): # ! subclass of Thread class
    def __init__(self, name, counter):
        Thread.__init__(self)
        self.name = name
        self.counter =counter
    
    def run(self):
        print ("Starting " + self.name)
        print_time(self.name, 5, self.counter)
        print ("Exiting " + self.name)
    
def print_time(threadName, counter, delay):
    while counter:
        if exitFlag:
            threadName.exit()
        time.sleep(delay)
        print ("%s: %s" % (threadName, time.ctime(time.time())), counter)
        counter -= 1

# ! istance new threads by subclass of Thread
thread1 = myThread("Thread-1", 1)
thread2 = myThread("Thread-2", 2)

# cosi i thread partirebero senza il parallelismo, uno aspetterebbe il termine dell'altro, perche in pratico cosi noi non stiamo andando a richiamare un metodo del genitore Thread che è start() che andrebbe a cercare le istruzioni da eseguire nel methodo run() del figlio, ma solo il metodo del figlio che è run() e basta, in pratica cosi andremmo a richiamare un semplice metodo della classe.
#print()
#thread1.run()
#print()
#thread2.run()

# * con start() i thread partono in parallelo uno dopo l'altro e lavorono in modo separato fino a che non finiscono le loro istruzioni
# * start() del genitore, va ad eseguire le istruzioni all'interno del metodo run() all'interno della classe figlia
# ! Start New Threads
#print()
#thread1.start()
#print()
#thread2.start()
#print()

#print ("Exiting Main Thread")

# ! Therminate a thread
# * https://www.geeksforgeeks.org/python-different-ways-to-kill-a-thread/
# Killing a thread abruptly might leave a critical resource that must be closed properly, open. But you might want to kill a thread once some specific time period has passed or some interrupt has been generated. 
# There are various methods by which you can kill a thread in python:
# --> Set/Reset stop flag
# --> Using the multiprocessing module to kill threads
# --> Killing Python thread by setting it as daemon
# --> Using a hidden function _stop()

# * Set/Reset stop flag
# * Set/Reset stop :
def run():
    while True:
        print('Thread running')
        global stop_threads
        if stop_threads:
            break

stop_threads = False
#t1 = Thread(target=run)
#t1.start()
#time.sleep(1)
#stop_threads = True
#t1.join()
#print('Thread killed')

# * Stop : 
def run1(stop):
    while True:
        print('tread running')
        if stop():
            time.sleep(1)
            break

def main():
    stop_threads = False
    t1 = Thread(target=run1, args=(lambda: stop_threads,)) # todo : studiare la funzione --> lambda
    t1.start()
    time.sleep(1)
    stop_threads = True
    t1.join() # aspetta che il tread t1 finisca prima di proseguire
    print('thread killed')

#main()

# * multiprocessing module : 
# the mumulti processing module of Python allows you to spawn processes in a similar way you spawn threads using the treading module. 
# Example : 
# * threading :
def func(name ,number):
    for i in range(0,10):
        time.sleep(0.1)
        print(f'{name} {number}: prints {number*i} ')

all_threads = []
for i in range(0,3):
    thread = Thread(target=func, args=('Thread', i))
    #thread.start()
    #all_threads.append(thread)

#for thread in all_threads:
#    thread.join()
    
#print('threads finished')

# * multiprocessing : 
#from multiprocessing import Process # todo: capire perchè non funziona
#for i in range(0,3):
#    process = Process(target=func, args=('Process', i))
#    process.start()
#    all_processes.append(process)

#for process in all_processes:
#    process.terminate()

# * Daemon : 
# are those threads which are killed when the main program exits. 
# To declair a thread as a daemon, we set the keyword argument, daemon as True.
#Si noti che, non appena termina il programma principale, il thread t1 viene ucciso. Questo metodo si rivela estremamente utile nei casi in cui la terminazione del programma può essere utilizzata per innescare l'uccisione di thread. Si noti che in Python il programma principale termina non appena tutti i thread non daemon sono morti, indipendentemente dal numero di thread demone attivi. Pertanto, le risorse detenute da questi thread demone, come file aperti, transazioni di database, ecc. Potrebbero non essere rilasciate correttamente. Il thread iniziale di controllo in un programma Python non è un thread demone. L'uccisione forzata di un thread non è consigliata a meno che non sia noto con certezza che ciò non causerà perdite o deadlock.
import sys
def funcDaemon():
    i = 0
    while True:
        time.sleep(0.5)
        print('Thread alive, and it will die on program termination', i)
        i += 1

#t1 = Thread(target=funcDaemon)
#t1.daemon = True
#t1.start()
##time.sleep(2)
#sys.exit()

# ! Syncronise a thread
x = 0
def increment_global():
    global x 
    x += 1

def taskoThread():
    
    for i in range(50000):
        increment_global()

def main1():
    global x
    x = 0

    t1 = Thread(target=taskoThread)
    t2 = Thread(target=taskoThread)

    t1.start()
    t2.start()

    t1.join()
    t2.join()

#for i in range(5):
#    main1()
#    print(f'x = {x} after iteration {i}')
# * After this excecution we will see the race condition
# ! Lock() : acquire(), release() : 
from threading import Lock

mutex = Lock()

class Player(Thread):

    def __init__(self, sound):
        Thread.__init__(self)
        self.sound = sound

    def run(self):
        global mutex
        for i in range(3):
            mutex.acquire()
            print(self.sound)
            time.sleep(1)
            mutex.release()

#t1 = Player('Ping')
#t2 = Player('Pong')
#t1.start()
#t2.start()
#t1.join()
#t2.join()

# ! Semaphore
# Un semaforo gestisce un contatore interno che viene decrementato da ciascuna chiamata acquisita () e incrementato da ciascuna chiamata release (). Il contatore non può mai andare sotto lo zero; quando acquisizione () rileva che è zero, si blocca, in attesa che alcune attività chiamino release (). L'argomento value facoltativo fornisce il valore iniziale per il contatore interno (1 per impostazione predefinita). Obsoleto dalla versione 3.8, verrà rimosso nella versione 3.10: il parametro loop.
from threading import Semaphore

sem = Semaphore()
x = 1

def fun1():
    while x:
        sem.acquire()
        print(1)
        sem.release()
        time.sleep(0.8)

def fun2():
    while x:
        sem.acquire()
        print(2)
        sem.release()
        time.sleep(0.8)

#t1 = Thread(target=fun1)
#t1.start()
#t2 = Thread(target=fun2)
#t2.start()
#time.sleep(3)
#x = 0
#t1.join()
#t2.join()

# ! Barrier Objects :
# Questa classe fornisce una semplice primitiva di sincronizzazione per l'uso da parte di un numero fisso di thread che devono attendersi a vicenda. Ciascuno dei thread tenta di superare la barriera chiamando il metodo wait () e si bloccherà fino a quando tutti i thread non avranno effettuato le loro chiamate wait (). A questo punto, i thread vengono rilasciati contemporaneamente.
# Barrier objects in python are used to wait for a fixed number of thread to complite the execution before any particular thread can proceed forward with the execution of the program. Each thread calls "wait()" function upon reaching the barrier. The barrier is responsible for keeping track of the number of "wait()" calls. If this number goes beyon the number of threads for wich the barrier was initialized with, then the barrier gives a way to the waiting threads to proceed on with execution.
from threading import Barrier

# * barrier = Barrier(number_of_threads, action=None, timeout=None)

barrier = Barrier(4)

class threadd(Thread):
    def __init__(self, thread_ID):
        Thread.__init__(self)
        self.thread_ID = thread_ID

    def run(self):
        barrier.wait()
        print(self.thread_ID)

#for i in range(8):
#    t = threadd(i + 1)
#    t.start()
#    time.sleep(0.5)

#print('Exit')

# ! QUEUE AND THREADS : implementing multiple thread
# ? da approfondire
# there can be multiple threads within a process where:
# Each thread contains its own set of registers and local variabeles (stored in a stack).
# All threads in a process share the global variabeles (stored  in heap) and the program code.

from queue import Queue

exitFlag = 0

class myThreadd(Thread):
    def __init__(self, threadID, name, q):
        Thread.__init__(self)
        self.threadID = threadID
        self.name = name
        self.q = q
    
    def run(self):
        print(f'Starting {self.name} ')
        process_data(self.name, self.q)
        print(f'Exiting {self.name} ')

def process_data(threadName, q):
    while not exitFlag:
        queueLock.acquire()
        if not workQueue.empty():
            data = q.get()
            queueLock.release()
            print(f'{threadName} processing {data} ')
        else:
            queueLock.release()
            time.sleep(1)

threadList = ['Thread-1','Thread-2','Thread-3']
nameList = ['one','two','Three', 'Four','Five']
queueLock = Lock()
workQueue = Queue(10)
threads = []
threadID = 1

# * Create new threads
#for tName in threadList:
#    thread = myThreadd(threadID, tName, workQueue)
#    thread.start()
#    threads.append(thread)
#    threadID += 1

#queueLock.acquire()
#for word in nameList:
#    workQueue.put(word)
#queueLock.release()

#while not workQueue.empty():
#    pass

#exitFlag = 1

#for t in threads:
#    t.join()
#print('Exit Main Thread')

# Il modulo Coda viene utilizzato principalmente per gestire l'elaborazione di grandi quantità di dati su più thread. Supporta la creazione di un nuovo oggetto coda che può accettare un numero distinto di elementi. I metodi get () e put () vengono utilizzati per aggiungere o rimuovere elementi da una coda rispettivamente. Di seguito è riportato l'elenco delle operazioni utilizzate per la gestione
# Come lo stack, la coda è una struttura di dati lineare che archivia gli elementi in modalità First In First Out (FIFO). Con una coda, l'elemento aggiunto meno di recente viene rimosso per primo. Un buon esempio di coda è qualsiasi coda di consumatori per una risorsa in cui viene servito per primo il consumatore che è arrivato per primo.

# ! Timer(interval, function, args=None, kwargs=None)
from threading import Timer

def hello():
    print('hello, Timer')

#t = Timer(3, hello)
#t.start()

# ! Riassunto
'''
____________________________________________________________________________________________________________________________
from threading import:

                                                        --> Thread: 
def function(param)

t = Thread(target = function, args =(param,))

class Name(Thread):
    def __init__(self, arg1, arg2, ...):
        Thread.__init__(self)
        self.arg1 = arg1
        ...
    def run(self):
        ...

t = Name(arg1, arg2, ...)

t.start()
t.join()


daemon:
t.daemon = True 
t.start()
sys.exit()

                                                        --> Lock:
mutex = Lock()
mutex.acquire()
...
mutex.release()

                                                        --> Semaphore:
sem = Semaphore()
sem.acquire()
...
sem.release()

                                                        --> Barrier:
barrier = Barrier(num)
barrier.wait()

                                                        --> Timer:
Timer(interval, function, args=None, kwargs=None)
t = Timer(3, function)
t.start()

___________________________________________________________________________________________________________________________

multiprocessing # todo capire perche non funziona
from multiprocessing import Process
___________________________________________________________________________________________________________________________

'''